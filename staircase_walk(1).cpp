#include <iostream>
#include <stdlib.h>
#include <time.h>
#include <iomanip>

using namespace std;

const int X = 8, Y = 8;                            /*設一個變數用於設定陣列(地圖)大小*/
int a[X][Y];                                       /*宣告一個二維陣列a用於讓C計算每下一步，該路徑的總值*/
int c[X][Y];                                       /*宣告一個二維陣列c用於儲存最終路徑的總值*/
int p[X][Y];                                       /*宣告一個二陣列p用於儲存路徑*/
int out[X+Y-1];                                    /*宣告一個一維陣列out，用於輸出最終取的唯一(最小)路徑(預設最少步數)*/
 
void staircase_walk()                              /*定義一個函式處理樓梯路徑*/
{
    // [Initial States]
    c[0][0] = a[0][0];                             /*初始化c和a陣列，兩陣列同世界*/
    p[0][0] = -1;   // 沒有源頭                    /*將路徑的起點設為-1表示不從任何地方走來*/
    for (int i=1; i<X; i++)                        /*創建一個迴圈初始化c和p的第一行的值*/
    {
        c[i][0] = c[i-1][0] + a[i][0];             /*將第一行的值，利用a陣列，更新在c陣列上，每次更新為這項值與上一格的值相加*/
        p[i][0] = 0;    // 從上走來                /*將P陣列第一行(只能從上走來的路徑)設為0*/
    }
    for (int j=1; j<Y; j++)                        /*創建一個迴圈初始化c和p的第一列的值*/
    {
        c[0][j] = c[0][j-1] + a[0][j];             /*將第一列的值，利用a陣列，更新在c陣列上，每次更新為這項值與左一格的值相加*/
        p[0][j] = 1;    // 從左走來                /*將第一列(只能從左走來的路徑)設為1*/
    }
 
    // [Computation]
    for (int i=1; i<X; i++)                        /*創一個迴圈用於更新從 c和 p的第二行開始的每個Y軸(列)*/
        for (int j=1; j<Y; j++)                    /*創一個迴圈用於更新從 c和 p的第二列開始的每個X軸(行)*/
            if (c[i-1][j] < c[i][j-1])             /*如果C陣列上，上面的值<左邊的值(代表從上走來是我要的最小路徑值)*/
            {
                c[i][j] = c[i-1][j] + a[i][j];     /*利用a陣列，將c每個點的值更新為在相同位置的值加上c上面的值*/
                p[i][j] = 0;    // 從上走來        /*並在p陣列上該點的值更新為0，代表我們選擇從上走下來(取路徑值小的上面)*/
            }
            else if (c[i-1][j] > c[i][j-1])        /*否則如果c陣列上，上面的值>左邊的值(代表從左走來是我要的最小路徑值)*/
            {
                c[i][j] = c[i][j-1] + a[i][j];     /*利用a陣列，將c每個點的值更新為在相同位置的值加上c左邊的值*/
                p[i][j] = 1;    // 從左走來        /*並在p陣列上該點的值更新為1，代表我們選擇左走過來(取路徑值小的左邊)*/
            }
            else /*if (c[i-1][j] == c[i][j-1])*/   /*以上皆非的情況，代表c的上和左值相等(==)*/
            {
                // 從上走來、從左走來都可以，這裡取左。
                c[i][j] = c[i][j-1] + a[i][j];     /*不管走哪都是一樣小的值(can also: c[i][j] = c[i-1][j] + a[i][j])*/
                p[i][j] = 1;                       /*如果是從上走來則p[i][j] = 0*/
            }
 
    // 反向追蹤路線源頭
    int n = 0;  // out size                        /*宣告一個整數n，用於out的索引值*/
    for (int i=X-1, j=Y-1; i>=0 && j>=0; )         /*從p(7, 7)倒退循環一直到 p(0, 0)含以外，即停止*/
    {
        out[n++] = p[i][j];                        /*每次循環，複製從p陣列將最終所走的最小路徑到out*/
        if (p[i][j] == 0) i--;                     /*如果p的該點值為0(代表從上走來)，將i-1(代表垂直往上一格)*/
        else if (p[i][j] == 1) j--;                /*又如果p的該點值為1(代表從左走來)，將j-1(代表平移往左一格)*/
    }
 
    // 印出路線
    for (int i=n-1; i>=0; --i)                     /*創建一個迴圈將out中的所有值反向輸出(當初輸入時是反向的，現在反反為正)*/
        cout << out[i];
}


int main(int argc, char** argv) {
	srand(time(NULL));              		       /*隨機函數*/ /*srand()依照()的參數產生亂數*/ /*time()依照目前時間*/
	
	int rows;
	int columns;
	int map[rows][columns];

	cin >> rows >> columns;
	
	for(int i=0; i<rows; i++){	
		for(int n=0; n<columns; n++){

			map[i][n] = (rand()%9)+1;
	
			cout << setw(2) << map[i][n];			  /**/
			
   		}
 		cout <<endl;
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	return 0;
}
